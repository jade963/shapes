<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Planning - Jade</title>
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="Description" lang="en" content="ADD SITE DESCRIPTION">
		<meta name="author" content="ADD AUTHOR INFORMATION">
		<meta name="robots" content="index, follow">

		<!-- icons -->
		<link rel="apple-touch-icon" href="assets/img/apple-touch-icon.png">
		<link rel="shortcut icon" href="favicon.ico">
<link rel="stylesheet" href="assets/highlight/styles/tomorrow.css">
<script src="assets/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
       

		<!-- Override CSS file - add your own CSS rules -->
		<link rel="stylesheet" href="assets/css/styles.css">
		<style>
			.center { 
			margin: 20px auto; 
			display: block;
			width: 600px; }
		</style>

	</head>
	<body>
		<div class="container">
			<div class="header">
				<h1 class="header-heading">Drawing project 2022</h1>
			</div>
			<div class="nav-bar">
				<ul class="nav">
					<li><a href="#brief">Brief</a></li>
					<li><a href="#sprint_one">Sprint One</a></li>
					<li><a href="#sprint_two">Sprint Two</a></li>
					<li><a href="#sprint_three">Sprint Three</a></li>
				</ul>
			</div>
			<div class="content">
					<h1><a id="brief">Brief</a></h1>
				<p>This project aims to create a basic drawing program after the fashion of Google Draw, for the use of
					 students in schools. The program should allow students to draw customisable shapes and lines. It
					needs to be based in a canvas environment.
				</p>
					<hr>
				<h1>Project Backlog</h1>
				<img class="img-responsive" src="assets/img/project_backlog.png" alt="">
				<hr>
    <!-- Heading levels -->
    <h1><a id="sprint_one">Sprint One</a></h1>
				<h2>Aim</h2>
				<p>By the end of this sprint the program should have a canvas, and the user should be able to click and
				drag to create a rectangle.</p>
				<h2>To-do</h2>
				<img class="img-responsive" src="assets/img/sprint_one_board.png" alt="">
	<h2>Planning</h2>
				<div class="col-container">
					<div class="col">
						<img class="img-responsive" src="assets/img/sprint_one_plan_one.jpg" alt="">
					</div>
					<div class="col">
						<img class="img-responsive" src="assets/img/sprint_one_plan_two.jpg" alt="">
					</div>
				</div>
	<h2>Testing</h2>
				<h3>Initial test</h3>
				<video class="center" controls>
					<source src="assets/video/sprint_one_test.mov" type="video/mp4">
					Your browser does not support the video tag.
				</video>
				<p>This video shows a test of the Sprint One code.<br><br>
					As can be seen, the sprint’s main goal of allowing the user to draw a permanent rectangle on the
					canvas has been achieved. However, there are a few bugs.
					<ol>
				<li>
					The program does not record when the mouse has left the canvas. As a result, if the mouse leaves
					the canvas while dragging a rectangle, the rectangle disappears. This is confusing and irritating
					for the user. It seems that it can only be fixed by the addition of strict limits around the
					drawing area - this is something that will take some consideration and is already planned for a
					later sprint, so I will leave this bug for now in the interest of prioritising.
				</li>
				<br>
				<li>
					The “guide” circle in the centre of the temporary rectangle that is shown while the user is
					dragging does not resize with the square. While this has no impact on the program’s functionality,
					it looks awkward and means that the user is not actually assisted by its presence as intended. I
					believe it could be fixed by making the radius responsive to the dimensions of
					the rectangle it is contained in, e.g.:
					<pre style="font-size: 1em">
					<code class="javascript">
						if(this.h < this.w){
								this.r = Math.abs(this.h/10)
							}
							else if(this.h > this.w){
								this.r = Math.abs(this.w/10)
							}</code>
					</pre>
					Here, the drawStrokeCircle function (the function for the guide circle) is able to recognise whether
					the width is less than the height or vice versa, and then make sure its radius stays
					smaller than it.
				</li>
			</ol>
				<br>
				<h3>Final test</h3>
				<video class="center" controls>
					<source src="assets/video/sprint_one_test_two.mov" type="video/mp4">
					Your browser does not support the video tag.
				</video>
				<p></p>
 	<h2>Reflection</h2>
				<p>As shown in the test above, the fixes applied to bug #2 found in the initial program test have been
				successful. Bug #1 has been added to the project backlog to be fixed in a later sprint.<br><br> On the
					whole
				this could be considered a successful sprint. Although the program is still extremely basic, I have a
				working canvas and an interactive platform, important fundamentals that will allow me to work on adding
				to the program in an efficient way. I have also been able to identify two bugs and fix one of them.
					<br><br> I think the next sprint should give the user more choice
				over how they use the program - in its current state, it's pretty boring. To allow the user to choose,
				I will have to code buttons and add some very basic shapes to the program's repertoire (e.g. a circle,
				line, and ellipse. I already have the code for these as they make up the "guide" shapes, making these
					additions quick and easy, allowing me to focus on the more complex code for buttons.)
					The buttons are another important fundamental that must work before I can
					add any more complicated functions, as this program is intended to be user-oriented and most of the
					planned features will simply be providing the user with new options. </p>
<hr>
<h1> <a id="sprint_two">Sprint Two</a> </h1>
				<h2>Aim</h2>
					<p>By the end of this sprint, the user should be able to draw either a rectangle, circle, line or
					an ellipse using buttons. </p>
				<h2>To-do</h2>
				<img class="img-responsive" src="assets/img/sprint_two_board.png" alt="">
				<h2>Planning</h2>
				<div class="col-container">
					<div class="col">
					<img class="img-responsive" src="assets/img/sprint_two_plan_one.JPG" alt="">
						</div>
					<div class="col">
					<img class="img-responsive" src="assets/img/sprint_two_plan_two.JPG" alt="">
						</div>
					<div class="col">
					<img class="img-responsive" src="assets/img/sprint_two_plan_three.JPG" alt="">
						</div>
					</div>
				<h2>Testing</h2>
				<h3>Component test #1 - new shapes</h3>
				<img class="img-responsive" src="assets/img/sprint_two_comptest_one.png" alt="">
				<p>This screenshot shows the successful implementation of part one of this sprint - the new shapes,
				drawn using their "basic" functions.</p>
				<h3>Component test #2 - drawing new shapes</h3>
				<video class="center" controls>
					<source src="assets/video/sprint_two_comptest_two.mov" type="video/mp4">
					Your browser does not support the video tag.
				</video>
				<p>This video shows an early test of the new shapes added to the program - the ellipse, circle, and
					line. Although the code is functional, some problems are revealed that interfere with the program's
					usability.<ol>
				<li>Placeholder code has been used at this stage, with the variable "this.choice" deciding
					which shape is to be drawn. This will be changed at the next step of this sprint when buttons are
					added - since the goal is for the user to be able to make changes without having to change the base
					code. because buttons have not yet been added. However, at this stage it is impossible for multiple
					shapes to be drawn on the canvas at once, because the page needs to be refreshed each time the
					drawing shape is changed. <br><br></li>
				<li>It appears that the bug found and fixed in Sprint One, where the guide circle inside the rectangle
				did not resize appropriately, was not fixed after all. This is because the code the guide circle uses
				to determine whether it should be sized according to the width or the height relied on an equation that
				calculated the width/height by subtracting the xMouse or yMouse value from the xStart or yStart
					value, then. However, this doesn't work because the user is able to make the width or height
					negative by simply dragging the mouse left or up from the Start point. Therefore, if the width is
				calculated to be -300, and the height is 30, the computer sees the width as smaller and therefore the
				radius resizes to be 1/10 of 300 (30) instead of 1/10 of 30 (3). This problem will require some
				consideration and different approaches and there is still a significant amount of work required for this
					sprint, so fixing it will be added to the agenda for Sprint Three.<br><br></li>
				<li>The final problem is with the guide shapes for the circle. The circle was added so the user had an
				option of creating the "perfect" shape, as an alternative to the ellipse. However, there is no
				equivalent "perfect" guide shape (which would be a square) to match it. The rectangle as its guide shape
				does not resize appropriately to the circle, because the width and the height are different. </li>
			</ol>
				<div class="col-container">
					<div class="col">
						<h3>Circle - error correction</h3>
						<img class="img-responsive" src="assets/img/sprint_two_error_one.jpg"></div>
					<div class="col">
						<h3>Final verdict</h3>
						<p>After solutions 1 and 2 proved unsuccessful, I began planning for solution
					#3, or the square function. However, during this time I realised that even a successful square or
					circle would be very restrictive to the user's freedom of movement, because it can only be expanded
					or contracted along a diagonal centre-line. This is true of squares even in programs such as Google
					Draw; by nature, the "perfect" shape is restrictive. I have decided, therefore, to scrap both the
					square and the circle functions. I believe the purpose of these functions can be much more
						efficiently served by the user simply choosing the rectangle or ellipse option, and if necessary
						use the grid as a guide to attain their desired proportions. Meanwhile, the user will not have
						to deal with the irritation of strict limits being placed on their range of movement - something
						that is rather the antithesis of the theoretical freedom a drawing program should allow. </p></div>
				</div>
				<h3>Component test #3 - buttons</h3>
				<video class="center" controls>
					<source src="assets/video/sprint_two_comptest_three.mov" type="video/mp4">
					Your browser does not support the video tag.
				</video>
				<p>This short video shows the buttons, still without any significant functionality, successfully
					recognising (changing colour) when
				the mouse is inBounds and when the button is selected.</p>
				<h3>Final test</h3>
				<video class="center" controls>
					<source src="assets/video/sprint_two_test.mov" type="video/mp4">
					Your browser does not support the video tag.
				</video>
				<h2>Reflection</h2>
				<p>As shown in the test above, the goals of this sprint have been met - the program now has a working
				button class as well as ellipse and line functions, although the intended circle class was scrapped.
				<br><br> To be fixed in the next sprint is the problem with the guide circle found when a rectangle is
				being drawn. The cause has been identified, and the fix will be part of the planning for sprint three.
				<br><br> In terms of general extension of the program, the next steps for this program are to allow the
					user the option
				not just to choose their shapes, but to choose the characteristics of those shapes - in sprint three,
				they should be able to toggle stroke & fill and have some influence over stroke and fill styles.
				<br><br>
					While reviewing the test, a few possible improvements have occurred to me. <br><br>
					First, there should be
					more differentiation between
					the "guide shapes" that the user sees while drawing a shape and the temporary outline of the actual
					shape - perhaps this could be differentiated by having the guide shapes as dotted lines, and the
					temporary version of the final shape as a solid one.<br><br>
					Second, there is currently no stroked edge around a button, and a selected button is indicated by a
					transparent fill shade. However, the plan for this sprint is to offer the user with a colour palette
					that allows them to choose the colour they want. If the appearance of a selected button is indicated
					by changing the colour of the button, this may cause confusion. Therefore, I would like to alter
					this functionality in the next sprint by adding a stroke around the buttons whenever the button is
					 selected, instead - this will align nicely with the main goal of the sprint.
				</p>
<hr>
<h1><a id="sprint_three">Sprint Three</a></h1>
				<h2>Aim</h2>
				<p>By the end of this sprint, the user should be able to toggle stroke & fill for their shapes, &
				dictate their colour. I also aim to solve a couple of minor glitches held over from the previous sprint.
				</p>
				<h2>To-do</h2>
				<img class="img-responsive" src="assets/img/sprint_three_board.png">
				<h2>Planning</h2>
				<div class="col-container">
					<div class="col">
				<img class="img-responsive" src="assets/img/sprint_three_plan_one.jpg">
					</div>
					<div class="col">
					<img class="img-responsive" src="assets/img/sprint_three_plan_two.jpg">
					</div>
					<div class="col">
						<img class="img-responsive" src="assets/img/sprint_three_plan_three.jpg">
					</div>
					<div class="col">
						<img class="img-responsive" src="assets/img/sprint_three_plan_four.jpg">
					</div>
					<h2>Testing</h2>
				<h3>Component test #1 - changes to button selection</h3>
					<video class="center" controls>
						<source src="assets/video/sprint_three_comptest_one.mov" type="video/mp4">
						Your browser does not support the video tag.
					</video>
					<p>This video shows the working change in button selection. <br>
					<h3>Component test #2 - guide circle bug fix</h3>
					<video class="center" controls>
						<source src="assets/video/sprint_three_comptest_two.mov" type="video/mp4">
						Your browser does not support the video tag.
					</video>
					<p>This video shows the successful bug fix, using the planned code.</p>
					<h3>Component test #3 - colour palette</h3>
					<video class="center" controls>
						<source src="assets/video/sprint_three_comptest_three.mov" type="video/mp4">
						Your browser does not support the video tag.
					</video>
					<p>This video shows the semi-successful implementation of the colour palette - it appears that you
						have to click twice to get anything to appear at all on the screen, which was not a problem
						in sprint two. This will be added to the to-do list for this sprint, to be corrected at the end.
					</p>
					<h3>Component test #4 - "Togglers"</h3>
					<div class="col-container">
						<div class="col">
					<video class="center" controls>
						<source src="assets/video/sprint_three_comptest_four.mov" type="video/mp4">
						Your browser does not support the video tag.
					</video>
							</div>
						<div class="col">
							<img src="assets/img/sprint_three_compfour_code.png">
							</div>
						<p>The implementation of the "Toggler" class has been completed with partial success.
							The "Toggle" switches themselves work fine as essentially a rework of the button class, with
							 some alterations to ensure that the Togglers are independent objects (so that more than one
							 Toggler can be selected at a time.) When stroke or fill is "on", they are highlighted and
							the text changes to reflect the status. Unfortunately, the code used in class Main to pass
							the information from the Togglers on to the draw() function doesn't actually work, and
							using the Togglers has no influence over stroke or fill. As shown by the console log,
							none of the code currently being used (see screenshot on the left above) is actually being
							received by the program. As can be seen from the red errors in the console log, the problem
							 is being caused by the program's inability to understand and interpret
							"Toggler.selected.type", a component of the while loops used here. To double-check this, I
							replaced the entire block of code pictured with the statements:
						<pre style="font-size: 1em">
						<code class="javascript">
							this.fillChoice = false
							this.strokeChoice = true</code></pre>
							This attained the desired result of a stroked box with no fill, which means that the problem
							 is certainly located inside the class Main code, and not the code in the Toggler class.
							Because this component is not working and will therefore require time and planning to
							complete, I will bump one of the remaining components for this sprint, which would allow
						the user to influence the width and style of their shape's stroke. This will be added to the
						project backlog at a later date. However, the other planned component, allowing the user to
						change stroke as well as fill colour, will remain as it should theoretically only need a few
						lines of code to implement. <br><br>
							One possibility for the current glitch is that the code calls "Toggler.selected", even when
						both Togglers are
							selected at once; as a result, when is asked to find which Toggler it is
							by identifying whether .type === "Fill" or "Stroke, it gets stuck at trying to figure out
							how to find "Toggler.selected". More specificity may be needed, therefore, I tested the
							following:
						<pre style="font-size: 1em">
						<code class="javascript">
							console.log(TStroke.status)
							console.log(TFill.status)
							</code> </pre>
							"TStroke.status" and "TFill.status" were correctly printed in the console log. This means
							that "Toggler.selected" can be replaced with either "TStroke" or "TFill", and the "while"
							loop currently being used will be obsolete and can be replaced with a series of "if"
							statements, e.g.:
							<pre style="font-size: 1em">
						<code class="javascript">
							if (TStroke.status === "on"){
							this.strokeChoice = true;
							}
							else if (TStroke.status === "off"){
							this.strokeChoice = false;
							}
							if (TFill.status === "on"){
							this.fillChoice = true;
							}
							else if (TFill.status === "off"){
							this.fillChoice = false;
							}
							</code> </pre>
						</p>
						<h3>Test - Togglers bug fix</h3>
						<video class="center" controls>
							<source src="assets/video/sprint_three_comp_four_fix.mov" type="video/mp4">
							Your browser does not support the video tag.
						</video>
						</div>
					<p>
					This video shows the successful bug fix, using the planned code. The "Toggler" component of this
						sprint is now complete.
					</p>
					<h3>Component test #5 - the Colour_Button class</h3>
					<div class="col-container">
						<div class="col">
							<video class="center" controls>
								<source src="assets/video/sprint_three_comptest_five.mov" type="video/mp4">
								Your browser does not support the video tag.
							</video>
						</div>
						<div class="col">
						<img class="img-responsive" src="assets/img/sprint_three_compfive_code.png">
						</div>
				</div>
				<p>
					This video shows the new Colour_Buttons working with the code above - clearly, there are pre-set
					fill and stroke colours, which the program is intended to default to at the beginning when neither
					of the Colour_Buttons has been selected. This also prevents undeclared variable errors. However, as
					 can be seen occurring in the video, when the user changes the fill colour after changing the stroke
					 colour with the buttons, the stroke colour reverts to the pre-set colour while the fill colour
					changes as it should. This was an oversight of my planning; clearly, there will need to be a
					method of storing the colour that the fill or stroke has been changed to. The easiest way to do this
					 in my mind would be by implementing an array to which fill or stroke information is added every
					 time one of the Colour_Buttons is clicked, e.g.: (the following in addition to adding
					this.strokeSet, this.fillSet, this.strokeColour and this.fillColour variables in the constructor)
					<pre style="font-size: 1em">
						<code class="javascript">
							if (this.edit_colourChoice === "Edit stroke colour"){
								strokeColour = Swatch.selected.fillC
								this.strokeSet = [strokeColour]
								fillColour = this.fillSet[0]
							}
							else if (this.edit_colourChoice === "Edit fill colour"){
								fillColour = Swatch.selected.fillC
								this.fillSet = [fillColour]
								strokeColour = this.strokeSet[0]
							}
							</code> </pre>
				</p>
					<h3>Final test - Colour_Button bug fix</h3>
					<video class="center" controls>
						<source src="assets/video/sprint_three_comp_five_fix.mov" type="video/mp4">
						Your browser does not support the video tag.
					</video>
					<p>This video shows the Colour_Button class, finally working, using the suggested code above.<p/>
					<h2>Reflections</h2>
					As shown in the test above, with the Colour_Button fixed, four out of five of the sprint's original
					goals have been met, with one of the planned components being dropped due to unexpected setbacks
					while working on components four and five. This will be returned to the project backlog where it
					will be added in a later sprint. <br><br>
					The program now allows the user to toggle stroke and fill for a shape and choose both its stroke and
					 fill colours. I am mostly happy with the approach I used in this sprint; most of the problems were
					caused by oversights or mistakes in the plannings and not altogether misguided approaches. There is
					one remaining bug, in that when the program is first booted up, you need to click once before the
					program begins drawing. I am assuming this is a problem with the code in the "Main" control class,
					and will review possible causes before planning my next sprint, with the intent to fix this problem
					sometime in Sprint Four. <br><br>
					The plan for Sprint Four is to introduce a smaller "drawing area" to the right of the "dashboard"
					area so that the user's controls and their canvas are separate. This is not only visually more
					convenient, but will prevent the irritating occurrence of shapes being drawn accidentally when the
					user clicks on a button/swatch/toggler etc., something that happens regularly and may cause
					confusion for the user. <br><br>
					While testing this sprint, I have also had several thoughts about how to make this program better in
					 the future. First of all, there should be some changes made to the "guide" shapes - in the last
					sprint I suggested that they should have dashed edges instead of solid ones, to convey their
					impermanence. I still think this; now I also believe that
					the colour of the guide shapes should be a transparent version of colour the shape will turn out to
					be. This is something I will look at in a sprint of its own. Another aspect I believe could be
					improved is the guide shape for the ellipse; having two lines form an 'X' shape instead of a '+' is
					much less helpful, and this is a very small, easy-to-fix detail that I can change in my next sprint.
					<hr>
				<h1>Sprint Four</h1>
				<h2>Aim</h2>
				<h2>To-do</h2>
				<h2>Planning</h2>
				<p>Link to the canvas Page</p>
				<h2>Testing</h2>
				<h2>Reflections</h2>
				<hr>
				<h1>Sprint Five</h1>
				<h2>Aim</h2>
				<h2>To-do</h2>
				<h2>Planning</h2>
				<p>Link to the canvas Page</p>
				<h2>Testing</h2>
				<h2>Reflections</h2>
				<hr>
<h1> Relevant Implications Summary</h1>
 <hr>
 <hr>
<!-- Paragraphs -->
<h3>Example code insert (don't do too much of this)</h3>
<pre style="font-size: 1.5em;">
<code class="javascript"> function inBoundsCheck(xM, yM, x, y, w, h){
        if( xM > x && xM < x+w && yM > y && yM < y+h){
            return true;
        }else{
            return false;
        }
    }</code>
</pre>
 
            <hr>     
                
                <h3>Video Test Example</h3>


				<video class="center" controls>
					<source src="assets/vids/littleTest.mp4" type="video/mp4">
				  Your browser does not support the video tag.
				  </video>
					<p>I hate you WebStorm</p>
					<hr>

					<!-- Responsive images -->
					<h3>Example image placements</h3>
					<p>For images to be responsive (so that they will rescale to suit the width of the parent, use the <code>.img-responsive</code> class.</p>
					<img class="img-responsive" src="assets/img/place_holder.png" alt="">
                <hr>
                <div class="col-container">
                <div class="col">
               <img class="img-responsive" src="assets/img/place_holder_sm.jpg" alt="">
                <p>I hate you WebStorm, <a href="#">I hate you WebStorm,</a>I hate you WebStorm</p>
                </div>
                 <div class="col">
                <img class="img-responsive" src="assets/img/place_holder_sm.jpg" alt="">
                <p>I hate you WebStorm, <a href="#">I hate you WebStorm,</a> I hate you WebStorm</p>
                </div>
                </div>
                <hr>
               
              

					<!-- Lists -->
					<h3>Unordered list</h3>
					<p>Unordered lists are used to markup lists where list items do not require numbering.</p>
					<ul>
						<li>UI hate you WebStorm</li>
						<li>I hate you WebStorm</li>
					</ul>
					<hr>

					<h3>Ordered list</h3>
					<p>Ordered lists are used to markup lists where list items require numbering.</p>
					<ol>
						<li>I hate you WebStorm</li>
						<li>I hate you WebStorm</li>
					</ol>
					<hr>

					<h3>Unstyled list</h3>
					<p>You can make the list unstyled using the <code>list-unstyled</code> class.</p>
					<ul class="list-unstyled">
						<li>I hate you WebStorm</li>
						<li>I hate you WebStorm</li>
					</ul>
					<hr>

					<h3>Inline list</h3>
					<p>You can make the list display inline using the <code>list-inline</code> class.</p>
					<ul class="list-inline">
						<li>One</li>
						<li>Two</li>
						<li>Three</li>
						<li>Four</li>
					</ul>
					<hr>

				

					<h3>Buttons</h3>
					<p>You can apply the <code>btn</code> class to any element that requires a button style.</p>
					<p><a href="#" class="btn">Submit</a></p>
					<hr>



               
            

			
			</div>
			<div class="footer">
				&copy; Copyright 2015
			</div>
		</div>
		</div>
	</body>
</html>